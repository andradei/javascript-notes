/*
  A short-hand way to writing anonymous functions.

  Differences:
    `arguments` doesn't exist in arrow functions.
    One-line arrow functions don't need a return statement.
    Multi-line arrow functions need a block and a return statement.
    Arrow functions doesn't rebind `this`, but takes the context in which it was defined with it.
*/

// ES5 Way:

function delegate (func, ...args) {
  return func(...args)
}

var sum = delegate(function () {
  return arguments[0] + arguments[1]
}, 3, 5)

console.log(sum)

// ES6 Way:

var sum2 = delegate((x, y) => x + y, 3, 5)
console.log(sum2)

// Concat an arbitrary number of strings
var concat = (...args) => {
  var result = ''
  args.forEach(a => result += a)
  return result
}

console.log(concat('Hello', 'World'))
console.log(concat('Many', 'Strings', 'To', 'Be', 'Concatenated'))

// ----------------------------------------------------------------------------------------------

// `this` binding difference.

// Classical object with a method:
var obj1 = {
  name: 'Obj 1',
  printName: function () { console.log(this.name) }
}

// `setTimeout()` makes its argument function be called from a different context (global),
// so the behavior is different.
var obj2 = {
  name: 'Obj 2',
  printName: function () {
    setTimeout(function () {
      console.log(this.name)
    }, 100)
  }
}

// Because arrow functions keep the context in which they were defined (it doesn't rebind `this`),
// the behavior remains the same.
var obj3 = {
  name: 'Obj 3',
  printName: function () {
    // The arrow function below won't rebind `this`.
    setTimeout(() => console.log(this.name), 100)
  }
}

// Classic function:
obj1.printName() // Prints `obj1.name`
obj2.printName() // Prints global object's `name` property, which is undefined
obj3.printName() // Prints `obj3.name`

// GOTCHAS:

// The arrow function below keep the context in which it was defined, so `this` is bound to the
// global object.
//
// In this case you want to create a regular function.
obj1.printName = () => console.log(`rebound ${this.name}`)
obj2.printName = () => {
  setTimeout(() => console.log(`rebound ${this.name}`), 100)
}

obj1.printName() // Prints `obj1.name`
obj2.printName() // Prints global object's `name` property, which is undefined

// Notice that `console.log` calls generated by `obj1` will happen first because they don't
// involve calls to `setTimeout`.
